from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
import json
import re
from packaging import version
from datetime import datetime, timedelta, UTC

from models.vulnerability import Vulnerability, Severity
from models.service_vulnerability import ServiceVulnerability, ConfidenceLevel
from models.service import Service
from .base import BaseRepository


class VulnerabilityRepository(BaseRepository[Vulnerability]):
    """Repository for vulnerability data access and version matching."""

    def __init__(self, db: Session):
        super().__init__(db, Vulnerability)

    def find_by_cve_id(self, cve_id: str) -> Optional[Vulnerability]:
        """Find vulnerability by CVE ID."""
        return self.session.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()

    def find_by_product_version(self, product: str, version_str: str) -> List[Vulnerability]:
        """
        Find vulnerabilities affecting a specific product and version.

        Args:
            product: Product name (e.g., 'OpenSSH', 'Apache httpd')
            version_str: Version string (e.g., '8.2p1', '2.4.41')

        Returns:
            List of vulnerabilities that affect this product/version
        """
        # First find vulnerabilities for this product
        product_vulns = self.session.query(Vulnerability).filter(
            Vulnerability.product.ilike(f"%{product}%")
        ).all()

        matching_vulns = []
        for vuln in product_vulns:
            if self._version_matches_vulnerability(version_str, vuln.affected_versions):
                matching_vulns.append(vuln)

        return matching_vulns

    def find_by_severity(self, severity: Severity) -> List[Vulnerability]:
        """Find vulnerabilities by severity level."""
        return self.session.query(Vulnerability).filter(Vulnerability.severity == severity).all()

    def find_exploitable(self) -> List[Vulnerability]:
        """Find vulnerabilities with available exploits."""
        return self.session.query(Vulnerability).filter(Vulnerability.exploit_available == True).all()

    def find_cisa_kev(self) -> List[Vulnerability]:
        """Find vulnerabilities in CISA KEV catalog."""
        return self.session.query(Vulnerability).filter(Vulnerability.cisa_kev == True).all()

    def search_by_description(self, search_term: str) -> List[Vulnerability]:
        """Search vulnerabilities by description text."""
        return self.session.query(Vulnerability).filter(
            Vulnerability.description.ilike(f"%{search_term}%")
        ).all()

    def find_recent(self, days: int = 30) -> List[Vulnerability]:
        """Find vulnerabilities published in the last N days."""
        since_date = datetime.now(UTC) - timedelta(days=days)

        return self.session.query(Vulnerability).filter(
            Vulnerability.published_date >= since_date
        ).order_by(Vulnerability.published_date.desc()).all()

    def _version_matches_vulnerability(self, version_str: str, affected_versions: Any) -> bool:
        """
        Check if a version matches the vulnerability's affected version ranges.

        Args:
            version_str: Version to check (e.g., '8.2p1')
            affected_versions: JSON data with version ranges

        Returns:
            True if version is affected by this vulnerability
        """
        if not affected_versions:
            return False

        try:
            # Parse affected_versions if it's a JSON string
            if isinstance(affected_versions, str):
                version_ranges = json.loads(affected_versions)
            else:
                version_ranges = affected_versions

            if not isinstance(version_ranges, list):
                return False

            # Normalize version for comparison
            normalized_version = self._normalize_version(version_str)
            if not normalized_version:
                return False

            # Check each range
            for version_range in version_ranges:
                if self._check_version_range(normalized_version, version_range):
                    return True

            return False

        except (json.JSONDecodeError, ValueError, TypeError) as e:
            # If we can't parse the version data, return False
            return False

    def _normalize_version(self, version_str: str) -> Optional[str]:
        """
        Normalize version string for comparison.

        Args:
            version_str: Original version string

        Returns:
            Normalized version string or None if invalid
        """
        if not version_str:
            return None

        # Remove common prefixes and suffixes
        clean_version = version_str.strip()

        # Handle OpenSSH versions (e.g., '8.2p1' -> '8.2.1')
        openssh_match = re.match(r'^(\d+\.\d+)p(\d+)$', clean_version)
        if openssh_match:
            major_minor, patch = openssh_match.groups()
            return f"{major_minor}.{patch}"

        # Handle basic semantic versions
        sem_ver_match = re.match(r'^(\d+\.\d+(?:\.\d+)?)(?:[^\d].*)?$', clean_version)
        if sem_ver_match:
            return sem_ver_match.group(1)

        # If we can't normalize, return the clean version
        return clean_version

    def _check_version_range(self, version_str: str, version_range: Dict[str, Any]) -> bool:
        """
        Check if a version falls within a specified range.

        Args:
            version_str: Normalized version string
            version_range: Dictionary with range specification

        Returns:
            True if version is in range
        """
        try:
            v = version.parse(version_str)

            # Handle exact version match
            if 'exact' in version_range:
                exact_version = self._normalize_version(version_range['exact'])
                if exact_version:
                    return v == version.parse(exact_version)

            # Handle range specifications
            if 'min' in version_range:
                min_version = self._normalize_version(version_range['min'])
                if min_version and v < version.parse(min_version):
                    return False

            if 'max' in version_range:
                max_version = self._normalize_version(version_range['max'])
                if max_version and v > version.parse(max_version):
                    return False

            # Handle inclusive/exclusive bounds
            if 'min_inclusive' in version_range:
                min_version = self._normalize_version(version_range['min_inclusive'])
                if min_version and v < version.parse(min_version):
                    return False

            if 'max_inclusive' in version_range:
                max_version = self._normalize_version(version_range['max_inclusive'])
                if max_version and v > version.parse(max_version):
                    return False

            if 'min_exclusive' in version_range:
                min_version = self._normalize_version(version_range['min_exclusive'])
                if min_version and v <= version.parse(min_version):
                    return False

            if 'max_exclusive' in version_range:
                max_version = self._normalize_version(version_range['max_exclusive'])
                if max_version and v >= version.parse(max_version):
                    return False

            return True

        except Exception:
            # If version parsing fails, fall back to string comparison
            return self._string_version_compare(version_str, version_range)

    def _string_version_compare(self, version_str: str, version_range: Dict[str, Any]) -> bool:
        """
        Fallback string-based version comparison.

        Args:
            version_str: Version string to check
            version_range: Range specification

        Returns:
            True if version matches range
        """
        # Simple exact match fallback
        if 'exact' in version_range:
            return version_str == version_range['exact']

        # If we can't do proper version comparison, be conservative
        return False

    def create_with_version_data(self, cve_id: str, product: str,
                               affected_versions: List[Dict[str, Any]],
                               severity: Severity, **kwargs) -> Vulnerability:
        """
        Create a new vulnerability with version range data.

        Args:
            cve_id: CVE identifier
            product: Product name
            affected_versions: List of version range specifications
            severity: Vulnerability severity
            **kwargs: Additional vulnerability fields

        Returns:
            Created vulnerability instance
        """
        vuln_data = {
            'cve_id': cve_id,
            'product': product,
            'affected_versions': json.dumps(affected_versions),
            'severity': severity,
            **kwargs
        }

        return self.create(**vuln_data)

    def get_statistics(self) -> Dict[str, Any]:
        """Get vulnerability database statistics."""
        total = self.session.query(Vulnerability).count()
        by_severity = {}

        for severity in Severity:
            count = self.session.query(Vulnerability).filter(
                Vulnerability.severity == severity
            ).count()
            by_severity[severity.value] = count

        exploitable = self.session.query(Vulnerability).filter(
            Vulnerability.exploit_available == True
        ).count()

        cisa_kev = self.session.query(Vulnerability).filter(
            Vulnerability.cisa_kev == True
        ).count()

        return {
            'total_vulnerabilities': total,
            'by_severity': by_severity,
            'exploitable': exploitable,
            'cisa_kev': cisa_kev
        }